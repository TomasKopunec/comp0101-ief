#!/bin/env python3
import sys
import yaml
import matplotlib.pyplot as plt
import random
from datetime import datetime,timedelta
import os
import itertools
import random
import requests
import json
import time

# Wait for 1 second

url = "http://localhost:5073/emissions/forecasts/current"

# Define the parameters
params1 = {
    'location': 'northeurope'
}


def calculate_subrange_allocation(timestamp_ranges, sampling):
    durations = []
    for range_str in timestamp_ranges:
        start_str, end_str = range_str.split(' - ')
        # Remove 'Z' and parse
        start = datetime.fromisoformat(start_str.rstrip('Z'))
        end = datetime.fromisoformat(end_str.rstrip('Z'))
        durations.append(end - start)
    total_duration = sum(durations, timedelta())
    allocations = [int(round(sampling * (duration / total_duration))) for duration in durations]
    
    # Adjust allocations to ensure the sum equals sampling
    while sum(allocations) > sampling:
        max_index = allocations.index(max(allocations))
        allocations[max_index] -= 1
    while sum(allocations) < sampling:
        min_index = allocations.index(min(allocations))
        allocations[min_index] += 1

    return allocations

def split_timestamp_ranges(timestamp_ranges, allocations):
    all_sub_ranges = []
    for (start_str, end_str), allocation in zip((range_str.split(' - ') for range_str in timestamp_ranges), allocations):
        # Remove 'Z' and parse
        start = datetime.fromisoformat(start_str.rstrip('Z'))
        end = datetime.fromisoformat(end_str.rstrip('Z'))
        sub_ranges = []
        for i in range(allocation):
            delta = (end - start) / allocation
            sub_start = start + delta * i
            sub_end = sub_start + delta
            # Append 'Z' to indicate UTC
            sub_ranges.append(f"{sub_start.isoformat()}Z - {sub_end.isoformat()}Z")
        all_sub_ranges.extend(sub_ranges)
    return all_sub_ranges

# Example usage in your main code block


def generate_combinations(times, locations):
    # Create all combinations of times and locations
    return list(itertools.product(times, locations))

def assign_random_values(combinations):
    # Assign a random value to each combination
    return [(combo, random.randint(1, 20)) for combo in combinations]

def sort_by_value(combo_values):
    # Sort combinations by their assigned value
    return sorted(combo_values, key=lambda x: x[1])

def plot_combinations(combo_values, filename):
    # Unzip the combination values for plotting
    combos, values = zip(*combo_values)

    # Formatting combinations for display
    formatted_combos = [f"{time}\n{location}" for time, location in combos]
    # print(formatted_combos,values)

    plt.figure(figsize=(15, 8))
    plt.bar(formatted_combos, values)
    plt.xticks(rotation=90)  # Rotate labels for better readability
    plt.title('Combinations of Times and Locations with Assigned Values')
    plt.xlabel('Time and Location Combinations')
    plt.ylabel('Carbon Emissions')

    # Save the plot to a file
    plt.tight_layout()  
    # plt.show()# Adjust layout to fit all x labels
    plt.savefig(filename, bbox_inches='tight')
    plt.close()
    #print(f"Diagram saved as {filename}")

current_path = os.getcwd()


# Function to assign random values


# Initialize an empty list to collect lines
input_lines = []

for line in sys.stdin:
    # Collect the lines
    input_lines.append(line)

# Join the collected lines into a single string
yaml_input = ''.join(input_lines)



try:
    # Parse the entire YAML input
    data = yaml.safe_load(yaml_input)[0]
    
    if data is not None:
        # Extract potential_times and potential_locations
        times = data['potential_times']
        locations = data['potential_locations']
        sampling = data['sampling']
# times = ["2023-11-02T10:35:31.820Z", "2023-11-02T10:40:31.820Z"]
# locations = ["Athens", "Spain"]
        allocations = calculate_subrange_allocation(times, sampling)
        #print(allocations)
        all_sub_ranges = split_timestamp_ranges(times, allocations)
        #print(all_sub_ranges)

        # Select an individual timestamp from each sub-range
        individual_times = [sub_range.split(' - ')[0] for sub_range in all_sub_ranges]  # Selects the start of each sub-range
        data['individual_times'] = individual_times
        response_values = []
        for ind_time in individual_times:
            time.sleep(1)
            response = requests.get(url, params=params1)
            
            # Check if the request was successful
            if response.status_code == 200:
                #print("Request was successful.")
                data1= json.loads(response.text)
                response_values.append(data1[0]['optimalDataPoints'][0]['value'])
                # Access and print the 'value' from 'optimalDataPoints'
                #print(data[0]['optimalDataPoints'][0]['value'])
                # Print the content of the response (as text)
                
            else:
                #print(f"Request failed with status code: {response.status_code}")
                response_values.append("error")
        #print(individual_times)
# Convert times to datetime objects and assign random values
        data['response_values'] = response_values
        combinations = generate_combinations(individual_times, locations)
        # print(combinations)


        combo_values = assign_random_values(combinations)
        sorted_combo_values = sort_by_value(combo_values)
        #print(sorted_combo_values)

# Plot and save the diagram
        plot_combinations(sorted_combo_values, "combinations_diagram.png")
        data['diagram'] = current_path + '/combinations_diagram.png'
        
        print(data)
    else:
        print("No valid YAML input provided.")
except yaml.YAMLError as e:
    print("Error parsing YAML:", e)
